//+-------------------------------------------------------------------+
//|                                              Tick-Tack-toe_v1.mq4 |
//|                                 Copyright © 2009, GoldenFox corp. |
//|                                                                   |
//|                     График "Крестики-Нолики"                      |
//|                                                                   |
//|                                                                   |
//| Метод отображения графика основан на скрипте Period_Converter.mq4 |
//| выложенный на сайте http://mql4.com/ru/                           |
//|                                                                   |
//| Для запуска скрипта необходимо перетащить его на текущий  график, |
//| в появившемся окне параметров скрипта на вкладке "Общие"  устано- |
//| вить галочку "Разрешить импорт функций из DLL", и  снять  галочку |
//| "Ручное подтверждение вызова".  На  вкладке  "Входные  параметры" |
//| установить необходимые параметры работы скрипта и нажать "ОК".    |
//|                                                                   |
//| Входные параметры:                                                |
//|   Kletka   - размер клетки в пунктах                              |
//|   RazvorotKletka - кол-во клеткок, необходимое для разворота      |
//|                                                                   |
//|          (значения по умолчанию взяты для пары EUR/USD и          |
//|              5-ти знаков после запятой в котировке)               |
//|                                                                   |
//| После появления на текущем графике информации о запуске,  необхо- |
//| димо открыть автономный двухминутный график по текущему инструме- |
//| нту следующим образом. В меню "Файл" выбрать "Открыть автономно", |
//| в появившемся окне найти двухминутный автономный график по вашему |
//| инструменту (например EURUSD,M2) и нажать кнопку  открыть.  Далее |
//| на открывшемся графике включить режим "Японские свечи".           |
//|                                                                   |
//| Построение графика по историческим данным содержащимся на текущем |
//| рабочем графике производится в соответствии с класическим  описа- |
//| нием графика "Крестики-Нолики". Далее график строится по  текущим |
//| котировкам.                                                       |
//|                                                                   |
//| В параметре "Объем" для каждой свечи отображается выcота столбика |
//| в пунктах, а в  качестве  времени  используется  время  окончания |
//| столбика.                                                         |
//|                                                                   |
//| Для более наглядного отображения текущей котировки последняя све- |
//| ча на графике отображается с тенью. Более старые свечи  отобража- |
//| ются без теней.                                                   |
//|                                                                   |
//+-------------------------------------------------------------------+

#property copyright "Copyright © 2009, GoldenFox Corp."
#property link      ""
#property show_inputs
#include <WinUser32.mqh>

static string s_ver="1.0"; //версия индикатора

extern int Kletka=50; //размер клетки в пунктах
extern int RazvorotKletka=2; //шум - кол-во клеток, считающихся шумами рынка
static int     Shum=0; //Величина Шума при нахождении направления
static int     ExtHandle=-1; //Указатель на файл котировок индикатора
static int     Kurs=0; //текущий курс в пунктах
static int     i_digits, i_time, i_open, i_low, i_high, i_close, i_last_close, last_fpos;
static double  d_point,d_volume=10.0;
static int     hwnd=0,cnt=0;
static int     ind_period=2; //Период графика индикатора
static int     i_period=0; //период текущего графика в минутах
static string  c_symbol; //символ текущего графика
static bool b_work=false; //fals - пишем историю; true - работаем

//+------------------------------------------------------------------+
//| script program start function                                    |
//+------------------------------------------------------------------+
int start()
{
//---- Заголовочные данные
   int    version=400;
   string c_copyright;
   c_copyright="(C)opyright 2003, MetaQuotes Software Corp.";
   c_symbol=Symbol();
   
   int i_unused[13];
   i_digits=Digits;   
   d_point=Point;
   i_period=Period()*60; //период текущего графика в минутах
   Shum=Kletka*RazvorotKletka;
  
//----  Cоздаем новый файл индикатора (двухминутный по текущему символу)
   ExtHandle=FileOpenHistory(c_symbol+ind_period+".hst", FILE_BIN|FILE_WRITE);
   if(ExtHandle < 0) return(-1); //если не открылся то выход с ошибкой       
   //---------Записываем заголовочные данные
   FileWriteInteger(ExtHandle, version, LONG_VALUE);  // 4 байта версия
   FileWriteString(ExtHandle, c_copyright, 64);       //64 байта копирайт
   FileWriteString(ExtHandle, c_symbol, 12);          //12 байт  символ
   FileWriteInteger(ExtHandle, ind_period, LONG_VALUE); // 4 байта период графика
   FileWriteInteger(ExtHandle, i_digits, LONG_VALUE); // 4 байта кол-во знаков после запятой
   FileWriteInteger(ExtHandle, 0, LONG_VALUE);        // 4 байта timesign
   FileWriteInteger(ExtHandle, 0, LONG_VALUE);        // 4 байта last_sync
   FileWriteArray(ExtHandle, i_unused, 0, 13);        //52 байт 
                                                 // всего 148 байт 
   WriteHistory();                                    //пишем историю.   
   if(hwnd==0)hwnd=WindowHandle(Symbol(),i_period);   //найдем окно индикатора
   if(hwnd!=0) PostMessageA(hwnd,WM_COMMAND,33324,0); //если есть окно, то обновим его  
   Comment("\nИндикатор Крестики-Нолики v",s_ver," запущен. Клетка: ",Kletka,"p. Разворот ", Shum, "p.",
           "\nОткройте автономный график ",c_symbol,",M",ind_period,
           "\n(Файл -> Открыть автономно -> ",c_symbol,",M",ind_period," -> Открыть)");
   RefreshRates();                                    //обновим котировку
   Kurs=(Bid/d_point)-MathMod(Bid/d_point,Kletka);    //нормализуем курс к клетке
   CalculateBar();                                    //добавим текущую котировку в файл        
//---------------- основной цикл
   while(IsStopped()==false) //Работаем пока не получена команда завершения
     { 
      if(RefreshRates())         //если есть новая котировка 
        {
         Kurs=(Bid/d_point)-MathMod(Bid/d_point,Kletka);    //новый нормализованный к клетке курс
         CalculateBar();                                    //добавим текущую котировку в файл        
        } 
     } 
//--------------------------------------
   return(0);
}
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+

void CalculateBar() //Функция обработки текущих котировок (котировки в пунктах)
{ 
   if (i_open>i_last_close)      //если открытие текущего бара индикатора больше закрытия, то напр.вниз
     {            
      if (i_last_close>Kurs)        //если предыдущее закрытие больше нормализованного курса
        {                           // то движение вниз продолжается. сохраним котировку
         i_time=TimeCurrent();         //время закрытия текущего бара индикатора равно текущему времени сервера
         i_close=Kurs;                 //закрытие текущего бара индикатора равно курсу
         i_low=i_close;                //минимум текущего бара индикатора равен закрытию
         i_last_close=i_low;           //сохраним минимум текущего бара индикатора
         WriteBar();                   //перепишем текущий бар индикатора
        } 
      else                          //иначе проверяем на разворот 
        { 
         if (Kurs-i_last_close>Shum)   //если разница нового курса и закрытия текущего бара индикатора больше шума
           {                           //то разворот (новый бар вверх)
            i_close=i_last_close;         //закрытие текущего бара индикатора равно равно его минимуму
            WriteBar();                   //перепишем текущий бар индикатора
            i_open=i_last_close+Kletka;   //открытие нового бара индикатора на клетку вверх
            i_low=i_open;                 //минимум нового бара индикатора равен его открытию
            i_close=Kurs;                 //закрытие нового бара индикатора равно курсу            
            i_high=i_close;               //максимум нового бара индикатора равен его закрытию
            i_last_close=i_high;          //сохраним максимум нового бара индикатора
            i_time=TimeCurrent();         //время закрытия нового бара индикатора равно текущему времени сервера
            WriteNewBar();                //запишем новый бар индикатора
           } 
         else                          //иначе шум не превышен, нарисуем тень
           {
            if (i_close!=Kurs)         //если закрытие текущего бара индикатора не равно курсу
              {                        //то перепишем текущий бар индикатора с тенью
               i_close=Kurs;              //закрытие текущего бара индикатора равно курсу       
               WriteBar();                //перепишем текущий бар индикатора
              }
           } 
        }             
     }
   else                            //иначе открытие текущего бара индикатора меньше закрытия (напр.вверх)
     {            
      if (i_last_close<Kurs)           //если предыдущее закрытие меньше нормализованного курса    
        {                              // то движение вверх продолжается. сохраним котировку
         i_time=TimeCurrent();            //время закрытия текущего бара индикатора равно текущему времени сервера
         i_close=Kurs;                    //закрытие текущего бара индикатора равно курсу           
         i_high=i_close;                  //максимум нового бара индикатора равен его закрытию      
         i_last_close=i_high;             //сохраним максимум нового бара индикатора
         WriteBar();                      //перепишем текущий бар индикатора
        } 
      else                             //иначе проверяем на разворот  
         if (i_last_close-Kurs>Shum)      //если разница закрытия текущего бара индикатора и нового курса больше шума
           {                              //то разворот (новый бар вниз)
            i_close=i_last_close;         //закрытие текущего бара индикатора равно равно его максимуму
            WriteBar();                   //перепишем текущий бар индикатора                      
            i_open=i_close-Kletka;        //открытие нового бара индикатора на клетку вниз
            i_high=i_open;                //максимум нового бара индикатора равен открытию предыдущего
            i_close=Kurs;                 //закрытие нового бара индикатора равно курсу
            i_low=i_close;                //минимум нового бара индикатора равен его закрытию
            i_last_close=i_low;           //сохраним минимум текущего бара индикатора
            i_time=TimeCurrent();         //время закрытия нового бара индикатора равно текущему времени сервера
            WriteNewBar();                //запишем новый бар индикатора                 
           }   
         else                          //иначе шум не превышен, нарисуем тень
           {                           
            if (i_close!=Kurs)            //если закрытие текущего бара индикатора не равно курсу
              {                           //то перепишем текущий бар индикатора с тенью
               i_close=Kurs;              //закрытие текущего бара индикатора равно курсу
               WriteBar();                //перепишем текущий бар индикатора
              }
           } 
     }
   return(0);
}
     
void WriteNewBar() //функция записи нового бара
{ 
   FileSeek(ExtHandle, last_fpos+44, SEEK_SET); //перемещаемся в конец файла   
   WriteBar();                                  //Записываем новый бар 
   return(0);
}
   
void WriteBar() //функция перезаписи текущего бара
{
   last_fpos=FileTell(ExtHandle); //получаем позицию последнего бара в файле
   FileWriteInteger(ExtHandle, i_time, LONG_VALUE);            //4 байта текущее время сервера
   FileWriteDouble(ExtHandle, i_open*d_point, DOUBLE_VALUE);     //8 байт открытие
   FileWriteDouble(ExtHandle, i_low*d_point, DOUBLE_VALUE);      //8 байт минимум
   FileWriteDouble(ExtHandle, i_high*d_point, DOUBLE_VALUE);     //8 байт максимум
   FileWriteDouble(ExtHandle, i_close*d_point, DOUBLE_VALUE);    //8 байт закрытие   
   FileWriteDouble(ExtHandle, i_high-i_low, DOUBLE_VALUE);     //8 байт высота бара в пунктах
   FileFlush(ExtHandle);                     //сброс буфера в файл
   FileSeek(ExtHandle, last_fpos, SEEK_SET); //перемещаемся на начало записанного бар
   if (b_work) //если не пишем историю, то обновим индикатор
     {
      if(hwnd==0)hwnd=WindowHandle(Symbol(),ind_period);   //найдем окно индикатора
      if(hwnd!=0) PostMessageA(hwnd,WM_COMMAND,33324,0); //если есть окно, то обновим его
     }   
   //Print ("Запись: время ",TimeToStr(i_time,TIME_DATE|TIME_MINUTES|TIME_SECONDS)," i_open ",i_open," i_low ",i_low," i_high ",i_high," i_close ",i_close," размах ",d_volume);
   return(0);
}
  
int WriteHistory() //функция записи истории
{ 
   b_work=false;                          //сносим флаг работы (пишем историю)
   int i=0;                               //индекс самого старого бара на текущем графике
   int t=0;                               //счетчик записанных баров в файл индикатора
   int l,h;                               //минимум и максимум текущего бара на текущем графике
   i=Bars-2;                              //берем индекс самого старого бара на текущем графике   
//----------------------Пишем самый первый бар
   i_time=Time[i]+i_period;               //время закрытия бара
   i_low=Low[i]/d_point;                  //минимум бара в пунктах
   i_low=i_low-MathMod(i_low,Kletka);     //нормализуем минимум к клетке
   i_high=High[i]/d_point;                //максимум бара в пунктах
   i_high=i_high-MathMod(i_high,Kletka);  //нормализуем максимум к клетке
   if (Open[i]>Close[i])                  //если открыти самого старого бара графика больше закрытия
     {                                    //то бар вниз
      i_open=i_high;                         //открытие первого бара индикатора равно максимуму бара графика
      i_close=i_low;                         //закрытие первого бара индикатора равно минимуму бара графика
     }
   else                                   //иначе самый старый бар графика вверх
     {
      i_open=i_low;                          //открытие первого бара индикатора равно минимуму бара графика
      i_close=i_high;                        //закрытие первого бара индикатора равно максимуму бара графика
     }  
   WriteBar();                            //запишем первый бар
//----------------------------------------------   
   
   for (i=i-1; i>=0; i--) //для всеx баров графика начиная со 2-го старейшего
     { 
      i_time=Time[i]+i_period;   //время закрытия текущего бара на графике
      if (i_open>i_close)        //если предыдущий бар индикатора вниз
        {
         l=Low[i]/d_point;          //минимум текущего бара на графике в пунктах
         l=l-MathMod(l,Kletka);     //нормализуем минимум к клетке
         if (l<i_close)             //если минимум текущего бара меньше последнего бара индикатора
           {                        // то движение вниз продолжается. сохраним котировку           
            i_close=l;                 //закрытие бара индикатора равно минимуму текущего бара
            i_low=l;                   //минимум бара индикатора равен минимуму текущего бара        
            WriteBar();                //перепишем бар индикатора
           } 
         else                       //иначе возможно разворот 
           {
            h=High[i]/d_point;         //максимум текущего бара на графике в пунктах
            h=h-MathMod(h,Kletka);     //нормализуем максимум к клетке   
            if (h-i_close>Shum)        //если разница максимума текущего бара и закрытия последнего бара индикатораи больше шума                 
              {                        //то разворот вверх
               i_open=i_close+Kletka;     //открытие нового бара индикатора на клетку вверх
               i_low=i_open;              //минимум нового бара индикатора равен открытию предыдущего бара индикатора
               i_close=h;                 //закрытие нового бара индикатора равно максимуму текущего бара графика
               i_high=h;                  //максимум нового бара индикатора равно максимуму текущего бара графика
               WriteNewBar();             //запишем новый бар индикатора
              } 
           }
        }
      else                       //иначе предыдущий бар индикатора вверх
        {
         h=High[i]/d_point;         //максимум текущего бара на графике
         h=h-MathMod(h,Kletka);     //нормализуем максимум к клетке  
         if (h>i_close)             //если максимум текущего бара больше последнего бара индикатора
           {                        // то движение вверх продолжается. сохраним котировку           
            i_close=h;                 //закрытие бара индикатора равно максимуму текущего бара
            i_high=h;                  //максимум бара индикатора равен максимуму текущего бара
            WriteBar();                //перепишем бар индикатора
           }
         else                       //иначе возможно разворот 
           {
            l=Low[i]/d_point;          //минимум текущего бара на графике в пунктах
            l=l-MathMod(l,Kletka);     //нормализуем минимум к клетке 
            if (i_close-l>Shum)        // если разница закрытия последнего бара индикатораи и минимума текущего бара больше шума                 
              {                        //то разворот вниз
               i_open=i_close-Kletka;     //открытие нового бара индикатора на клетку вниз
               i_high=i_open;             //максимум нового бара индикатора равен открытию предыдущего бара индикатора
               i_close=l;                 //закрытие нового бара индикатора равно минимуму текущего бара графика
               i_low=l;                   //минимум нового бара индикатора равен минимуму текущего бара графика
               WriteNewBar();             //запишем новый бар индикатора
              } 
           }
        }   
 //----------через каждые 1000 записей  обновим окно индикатора если есть и нарисуем коментарий
      t++;           //увеличим счетчик записи баров индикатора
      if (t>1000)
        {
         t=0;
         if(hwnd==0)hwnd=WindowHandle(Symbol(),ind_period);   //найдем окно индикатора
         if(hwnd!=0) PostMessageA(hwnd,WM_COMMAND,33324,0); //если есть окно, то обновим его
         Comment ("\nИндикатор Крестики-Нолики v",s_ver," запущен. Клетка: ",Kletka,"p. Разворот ", Shum, "p.",
                     "\nОткройте автономный график ",c_symbol,",M",ind_period,
                     "\n(Файл -> Открыть автономно -> ",c_symbol,",M",ind_period," -> Открыть)",
                     "\n\nПишем историю: Время ",TimeToStr(i_time,TIME_DATE|TIME_MINUTES|TIME_SECONDS));         
        }
     }   
   i_last_close=i_close;   // сохраним закрытие последнего бара индикатора
   b_work=true;            //установим флаг работы (закончили писать историю: работаем)
   return(0);
} 
      
void deinit() //выгрузка скрипта индикатора
{
   if(ExtHandle>=0) { FileClose(ExtHandle); ExtHandle=-1; } //закроем файл индикатора если есть
   Comment("\nСкрипт Крестики-нолики v",s_ver," выгружен");
}


